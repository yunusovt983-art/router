@startuml Task7_Code_Diagram
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml

title Auto.ru Federation - Code Diagram (Task 7: Error Handling & Resilience Implementation)

System_Boundary(error_handling_implementation, "Error Handling Implementation") {
    
    System_Boundary(error_types_impl, "Error Types Implementation") {
        Component(ugc_error_impl, "UgcError", "Rust Enum", "pub enum UgcError {\n    // Client errors (4xx)\n    ReviewNotFound { id: Uuid },\n    Unauthorized { user_id: Uuid, review_id: Uuid },\n    ValidationError { message: String },\n    AuthenticationError(String),\n    RateLimitExceeded { user_id: Uuid },\n    Forbidden,\n\n    // Server errors (5xx)\n    DatabaseError(#[from] sqlx::Error),\n    ExternalServiceError { service: String, message: String },\n    CircuitBreakerOpen { service: String },\n    ServiceTimeout { service: String },\n    CacheError(String),\n    ConnectionPoolExhausted,\n    ConfigError(#[from] anyhow::Error),\n    InternalError(String),\n}")
        
        Component(error_extensions_impl, "ErrorExtensions Implementation", "Rust Trait Impl", "impl ErrorExtensions for UgcError {\n    fn extend(&self) -> async_graphql::Error {\n        self.log_error();\n        let mut error = async_graphql::Error::new(self.to_string());\n        \n        match self {\n            UgcError::ReviewNotFound { id } => {\n                error = error.extend_with(|_, e| {\n                    e.set(\"code\", \"REVIEW_NOT_FOUND\");\n                    e.set(\"reviewId\", id.to_string());\n                    e.set(\"category\", \"CLIENT_ERROR\");\n                    e.set(\"retryable\", false);\n                });\n            }\n            UgcError::CircuitBreakerOpen { service } => {\n                error = error.extend_with(|_, e| {\n                    e.set(\"code\", \"CIRCUIT_BREAKER_OPEN\");\n                    e.set(\"service\", service.clone());\n                    e.set(\"category\", \"SERVER_ERROR\");\n                    e.set(\"retryable\", true);\n                });\n            }\n            // ... other error variants\n        }\n        error\n    }\n}")
        
        Component(error_logging_impl, "Error Logging Implementation", "Rust Methods", "impl UgcError {\n    pub fn log_error(&self) {\n        match self {\n            UgcError::ReviewNotFound { id } => {\n                info!(\n                    error = %self,\n                    review_id = %id,\n                    error_code = \"REVIEW_NOT_FOUND\",\n                    \"Review not found\"\n                );\n            }\n            UgcError::Unauthorized { user_id, review_id } => {\n                warn!(\n                    error = %self,\n                    user_id = %user_id,\n                    review_id = %review_id,\n                    error_code = \"UNAUTHORIZED\",\n                    \"Unauthorized access attempt\"\n                );\n            }\n            UgcError::DatabaseError(db_err) => {\n                error!(\n                    error = %self,\n                    db_error = %db_err,\n                    error_code = \"DATABASE_ERROR\",\n                    \"Database operation failed\"\n                );\n            }\n        }\n    }\n\n    pub fn is_retryable(&self) -> bool {\n        matches!(\n            self,\n            UgcError::DatabaseError(_)\n                | UgcError::ExternalServiceError { .. }\n                | UgcError::ServiceTimeout { .. }\n                | UgcError::CacheError(_)\n                | UgcError::ConnectionPoolExhausted\n                | UgcError::RateLimitExceeded { .. }\n        )\n    }\n\n    pub fn category(&self) -> &'static str {\n        match self {\n            UgcError::ReviewNotFound { .. }\n            | UgcError::Unauthorized { .. }\n            | UgcError::ValidationError { .. }\n            | UgcError::AuthenticationError(_)\n            | UgcError::RateLimitExceeded { .. }\n            | UgcError::Forbidden => \"CLIENT_ERROR\",\n\n            _ => \"SERVER_ERROR\",\n        }\n    }\n}")
    }
    
    System_Boundary(circuit_breaker_impl, "Circuit Breaker Implementation") {
        Component(circuit_breaker_struct, "CircuitBreaker", "Rust Struct", "pub struct CircuitBreaker {\n    config: CircuitBreakerConfig,\n    state: Arc<RwLock<CircuitState>>,\n    failure_count: AtomicUsize,\n    success_count: AtomicUsize,\n    last_failure_time: AtomicU64,\n    last_success_time: AtomicU64,\n    service_name: String,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum CircuitState {\n    Closed,\n    Open,\n    HalfOpen,\n}\n\n#[derive(Debug, Clone)]\npub struct CircuitBreakerConfig {\n    pub failure_threshold: usize,\n    pub timeout: Duration,\n    pub success_threshold: usize,\n    pub failure_window: Duration,\n}")
        
        Component(circuit_breaker_methods, "CircuitBreaker Methods", "Rust Implementation", "impl CircuitBreaker {\n    pub async fn call<F, Fut, T>(&self, f: F) -> Result<T, UgcError>\n    where\n        F: FnOnce() -> Fut,\n        Fut: std::future::Future<Output = Result<T, UgcError>>,\n    {\n        // Check if circuit is open\n        if self.is_open().await {\n            return Err(UgcError::CircuitBreakerOpen {\n                service: self.service_name.clone(),\n            });\n        }\n\n        // Execute the function\n        match f().await {\n            Ok(result) => {\n                self.on_success().await;\n                Ok(result)\n            }\n            Err(err) => {\n                self.on_failure().await;\n                Err(err)\n            }\n        }\n    }\n\n    async fn is_open(&self) -> bool {\n        let state = self.state.read().await;\n        match *state {\n            CircuitState::Open => {\n                let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as u64;\n                let last_failure = self.last_failure_time.load(Ordering::Relaxed);\n                \n                if now - last_failure >= self.config.timeout.as_nanos() as u64 {\n                    drop(state);\n                    self.transition_to_half_open().await;\n                    false\n                } else {\n                    true\n                }\n            }\n            _ => false,\n        }\n    }\n\n    async fn on_success(&self) {\n        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as u64;\n        self.last_success_time.store(now, Ordering::Relaxed);\n\n        let state = self.state.read().await;\n        match *state {\n            CircuitState::HalfOpen => {\n                let success_count = self.success_count.fetch_add(1, Ordering::Relaxed) + 1;\n                if success_count >= self.config.success_threshold {\n                    drop(state);\n                    self.transition_to_closed().await;\n                }\n            }\n            CircuitState::Closed => {\n                self.failure_count.store(0, Ordering::Relaxed);\n            }\n            _ => {}\n        }\n    }\n\n    async fn on_failure(&self) {\n        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos() as u64;\n        self.last_failure_time.store(now, Ordering::Relaxed);\n\n        let state = self.state.read().await;\n        match *state {\n            CircuitState::Closed => {\n                let failure_count = self.failure_count.fetch_add(1, Ordering::Relaxed) + 1;\n                if failure_count >= self.config.failure_threshold {\n                    drop(state);\n                    self.transition_to_open().await;\n                }\n            }\n            CircuitState::HalfOpen => {\n                drop(state);\n                self.transition_to_open().await;\n            }\n            _ => {}\n        }\n    }\n}")
        
        Component(retry_mechanism_impl, "RetryMechanism", "Rust Struct", "pub struct RetryMechanism {\n    config: RetryConfig,\n}\n\n#[derive(Debug, Clone)]\npub struct RetryConfig {\n    pub max_attempts: usize,\n    pub initial_delay: Duration,\n    pub max_delay: Duration,\n    pub backoff_multiplier: f64,\n}\n\nimpl RetryMechanism {\n    pub async fn call<F, Fut, T>(&self, mut f: F) -> Result<T, UgcError>\n    where\n        F: FnMut() -> Fut,\n        Fut: std::future::Future<Output = Result<T, UgcError>>,\n    {\n        let mut attempt = 0;\n        let mut delay = self.config.initial_delay;\n\n        loop {\n            attempt += 1;\n            \n            match f().await {\n                Ok(result) => return Ok(result),\n                Err(err) => {\n                    if !err.is_retryable() || attempt >= self.config.max_attempts {\n                        return Err(err);\n                    }\n\n                    warn!(\n                        attempt = attempt,\n                        max_attempts = self.config.max_attempts,\n                        delay_ms = delay.as_millis(),\n                        error = %err,\n                        \"Retrying failed operation\"\n                    );\n\n                    tokio::time::sleep(delay).await;\n\n                    delay = std::cmp::min(\n                        Duration::from_millis(\n                            (delay.as_millis() as f64 * self.config.backoff_multiplier) as u64\n                        ),\n                        self.config.max_delay,\n                    );\n                }\n            }\n        }\n    }\n}")
    }
    
    System_Boundary(fallback_impl, "Fallback Implementation") {
        Component(fallback_provider_impl, "FallbackDataProvider", "Rust Struct", "pub struct FallbackDataProvider {\n    user_cache: Arc<InMemoryCache<ExternalUser>>,\n    offer_cache: Arc<InMemoryCache<ExternalOffer>>,\n}\n\nimpl FallbackDataProvider {\n    pub fn new() -> Self {\n        Self {\n            user_cache: Arc::new(InMemoryCache::new(Duration::from_secs(300))),\n            offer_cache: Arc::new(InMemoryCache::new(Duration::from_secs(300))),\n        }\n    }\n\n    pub async fn cache_user(&self, user: &ExternalUser) {\n        let key = format!(\"user:{}\", user.id);\n        self.user_cache.set(key, user.clone()).await;\n    }\n\n    pub async fn get_user_fallback(&self, user_id: Uuid) -> ExternalUser {\n        let key = format!(\"user:{}\", user_id);\n        \n        if let Some(cached_user) = self.user_cache.get(&key).await {\n            info!(\"Using cached user data for fallback: {}\", user_id);\n            cached_user\n        } else {\n            warn!(\"No cached user data available, using minimal fallback: {}\", user_id);\n            ExternalUser {\n                id: user_id,\n                name: \"Unknown User\".to_string(),\n                email: None,\n            }\n        }\n    }\n}")
        
        Component(cache_impl, "InMemoryCache", "Rust Generic Struct", "pub struct InMemoryCache<T> {\n    data: Arc<RwLock<HashMap<String, CacheEntry<T>>>>,\n    default_ttl: Duration,\n}\n\n#[derive(Debug, Clone)]\nstruct CacheEntry<T> {\n    value: T,\n    expires_at: Instant,\n}\n\nimpl<T: Clone> InMemoryCache<T> {\n    pub fn new(default_ttl: Duration) -> Self {\n        Self {\n            data: Arc::new(RwLock::new(HashMap::new())),\n            default_ttl,\n        }\n    }\n\n    pub async fn get(&self, key: &str) -> Option<T> {\n        let data = self.data.read().await;\n        if let Some(entry) = data.get(key) {\n            if !entry.is_expired() {\n                debug!(\"Cache hit for key: {}\", key);\n                return Some(entry.value.clone());\n            } else {\n                debug!(\"Cache entry expired for key: {}\", key);\n            }\n        }\n        None\n    }\n\n    pub async fn set(&self, key: String, value: T) {\n        let mut data = self.data.write().await;\n        data.insert(key.clone(), CacheEntry::new(value, self.default_ttl));\n        debug!(\"Cached value for key: {}\", key);\n    }\n}")
        
        Component(service_health_impl, "ServiceHealthMonitor", "Rust Struct", "pub struct ServiceHealthMonitor {\n    service_status: Arc<RwLock<HashMap<String, ServiceHealth>>>,\n}\n\n#[derive(Debug, Clone)]\npub struct ServiceHealth {\n    pub service_name: String,\n    pub is_healthy: bool,\n    pub last_check: Instant,\n    pub consecutive_failures: usize,\n    pub last_error: Option<String>,\n}\n\nimpl ServiceHealthMonitor {\n    pub async fn record_success(&self, service_name: &str) {\n        let mut status = self.service_status.write().await;\n        status.insert(\n            service_name.to_string(),\n            ServiceHealth {\n                service_name: service_name.to_string(),\n                is_healthy: true,\n                last_check: Instant::now(),\n                consecutive_failures: 0,\n                last_error: None,\n            },\n        );\n    }\n\n    pub async fn record_failure(&self, service_name: &str, error: &str) {\n        let mut status = self.service_status.write().await;\n        let health = status.entry(service_name.to_string()).or_insert_with(|| ServiceHealth {\n            service_name: service_name.to_string(),\n            is_healthy: true,\n            last_check: Instant::now(),\n            consecutive_failures: 0,\n            last_error: None,\n        });\n\n        health.is_healthy = false;\n        health.consecutive_failures += 1;\n        health.last_error = Some(error.to_string());\n    }\n}")
    }
    
    System_Boundary(external_service_impl, "External Service Implementation") {
        Component(external_service_client_impl, "ExternalServiceClient", "Rust Struct", "pub struct ExternalServiceClient {\n    client: Client,\n    users_service_url: String,\n    offers_service_url: String,\n    users_circuit_breaker: Arc<CircuitBreaker>,\n    offers_circuit_breaker: Arc<CircuitBreaker>,\n    retry_mechanism: Arc<RetryMechanism>,\n    fallback_provider: Arc<FallbackDataProvider>,\n    health_monitor: Arc<ServiceHealthMonitor>,\n}\n\nimpl ExternalServiceClient {\n    #[instrument(skip(self))]\n    pub async fn get_user(&self, user_id: Uuid) -> Result<Option<ExternalUser>, UgcError> {\n        let client = self.client.clone();\n        let url = format!(\"{}/users/{}\", self.users_service_url, user_id);\n        \n        self.users_circuit_breaker\n            .call(|| {\n                let client = client.clone();\n                let url = url.clone();\n                async move {\n                    self.retry_mechanism\n                        .call(|| {\n                            let client = client.clone();\n                            let url = url.clone();\n                            async move {\n                                self.make_user_request(client, url, user_id).await\n                            }\n                        })\n                        .await\n                }\n            })\n            .await\n    }\n\n    pub async fn get_user_with_fallback(&self, user_id: Uuid) -> ExternalUser {\n        match self.get_user(user_id).await {\n            Ok(Some(user)) => user,\n            Ok(None) => {\n                warn!(\"User {} not found, using fallback\", user_id);\n                self.fallback_provider.get_user_fallback(user_id).await\n            }\n            Err(e) => {\n                error!(\"Failed to fetch user {}: {}, using fallback\", user_id, e);\n                self.fallback_provider.get_user_fallback(user_id).await\n            }\n        }\n    }\n}")
        
        Component(graphql_integration_impl, "GraphQL Integration", "Rust Implementation", "// GraphQL Resolver with Error Handling\nimpl Mutation {\n    async fn create_review(\n        &self,\n        ctx: &Context<'_>,\n        input: CreateReviewInput,\n    ) -> FieldResult<Review> {\n        let user_context = ctx.data::<UserContext>()?;\n        let external_service = ctx.data::<Arc<ExternalServiceClient>>()?;\n        \n        // Get user with fallback\n        let user = external_service\n            .get_user_with_fallback(user_context.user_id)\n            .await;\n        \n        // Create review with error handling\n        match self.review_service.create_review(input, &user_context).await {\n            Ok(review) => Ok(review),\n            Err(UgcError::ValidationError { message }) => {\n                Err(async_graphql::Error::new(message))\n            }\n            Err(UgcError::ExternalServiceError { service, message }) => {\n                warn!(\"External service {} failed: {}\", service, message);\n                // Return partial result or cached data\n                self.create_review_with_fallback(input, &user_context).await\n            }\n            Err(e) => Err(e.extend()),\n        }\n    }\n}\n\n// Middleware Integration\npub async fn resilience_middleware(\n    request: Request,\n    next: Next,\n) -> Result<Response, UgcError> {\n    let start_time = Instant::now();\n    \n    match next.run(request).await {\n        Ok(response) => {\n            // Record success metrics\n            RESPONSE_TIME_HISTOGRAM\n                .with_label_values(&[\"success\"])\n                .observe(start_time.elapsed().as_secs_f64());\n            Ok(response)\n        }\n        Err(err) => {\n            // Log error and record metrics\n            err.log_error();\n            ERROR_COUNTER\n                .with_label_values(&[err.category()])\n                .inc();\n            \n            Err(err)\n        }\n    }\n}")
    }
}

' Relationships between error handling classes
Rel(ugc_error_impl, error_extensions_impl, "implements trait", "trait implementation")
Rel(ugc_error_impl, error_logging_impl, "contains methods", "method implementation")

' Circuit breaker relationships
Rel(circuit_breaker_struct, circuit_breaker_methods, "implements methods", "method implementation")
Rel(circuit_breaker_methods, retry_mechanism_impl, "uses for retry", "composition")

' Fallback relationships
Rel(fallback_provider_impl, cache_impl, "uses cache", "composition")
Rel(fallback_provider_impl, service_health_impl, "monitors health", "composition")

' External service integration
Rel(external_service_client_impl, circuit_breaker_struct, "uses circuit breaker", "composition")
Rel(external_service_client_impl, retry_mechanism_impl, "uses retry", "composition")
Rel(external_service_client_impl, fallback_provider_impl, "uses fallback", "composition")
Rel(external_service_client_impl, service_health_impl, "monitors health", "composition")

' GraphQL integration
Rel(graphql_integration_impl, ugc_error_impl, "handles errors", "error processing")
Rel(graphql_integration_impl, external_service_client_impl, "calls services", "service integration")

' Cross-cutting concerns
Rel(circuit_breaker_methods, ugc_error_impl, "returns errors", "error creation")
Rel(retry_mechanism_impl, ugc_error_impl, "checks retryable", "error analysis")
Rel(fallback_provider_impl, ugc_error_impl, "handles failures", "error recovery")

SHOW_LEGEND()
@enduml