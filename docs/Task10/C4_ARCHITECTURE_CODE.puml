@startuml Task10_Code_Diagram
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml

title Auto.ru Federation - Code Diagram (Task 10: Testing Infrastructure Implementation)

System_Boundary(unit_testing_implementation, "Unit Testing Implementation") {
    
    System_Boundary(test_framework_impl, "Test Framework Implementation") {
        Component(test_config_impl, "TestConfig", "Rust Struct", "pub struct TestConfig {\n    pub database_url: String,\n    pub redis_url: String,\n    pub external_services: HashMap<String, String>,\n    pub test_timeout: Duration,\n    pub parallel_tests: bool,\n}\n\nimpl Default for TestConfig {\n    fn default() -> Self {\n        Self {\n            database_url: \"postgresql://test:test@localhost:5433/test_db\".to_string(),\n            redis_url: \"redis://localhost:6380\".to_string(),\n            external_services: HashMap::new(),\n            test_timeout: Duration::from_secs(30),\n            parallel_tests: true,\n        }\n    }\n}")
        
        Component(test_harness_impl, "TestHarness", "Rust Implementation", "pub struct TestHarness {\n    config: TestConfig,\n    db_pool: Option<PgPool>,\n    redis_client: Option<redis::Client>,\n    mock_server: Option<MockServer>,\n}\n\nimpl TestHarness {\n    pub async fn new() -> Result<Self, TestError> {\n        let config = TestConfig::default();\n        Ok(Self {\n            config,\n            db_pool: None,\n            redis_client: None,\n            mock_server: None,\n        })\n    }\n    \n    pub async fn setup_database(&mut self) -> Result<(), TestError> {\n        let pool = PgPoolOptions::new()\n            .max_connections(5)\n            .connect(&self.config.database_url)\n            .await?;\n        \n        sqlx::migrate!(\"./migrations\")\n            .run(&pool)\n            .await?;\n            \n        self.db_pool = Some(pool);\n        Ok(())\n    }\n}")
        
        Component(mock_factory_impl, "MockFactory", "Rust Trait + Implementation", "pub trait MockFactory<T> {\n    fn create_mock() -> T;\n    fn with_behavior(behavior: MockBehavior) -> T;\n}\n\n#[derive(Clone)]\npub enum MockBehavior {\n    Success(serde_json::Value),\n    Error(String),\n    Timeout(Duration),\n    Custom(Box<dyn Fn() -> Result<serde_json::Value, String>>),\n}\n\nimpl MockFactory<MockReviewService> for MockReviewService {\n    fn create_mock() -> MockReviewService {\n        let mut mock = MockReviewService::new();\n        mock.expect_create_review()\n            .returning(|input| Ok(Review {\n                id: Uuid::new_v4(),\n                content: input.content,\n                rating: input.rating,\n                created_at: Utc::now(),\n                ..Default::default()\n            }));\n        mock\n    }\n}")
    }
    
    System_Boundary(assertion_framework_impl, "Assertion Framework Implementation") {
        Component(custom_assertions_impl, "CustomAssertions", "Rust Macros", "macro_rules! assert_graphql_response {\n    ($response:expr, $expected:expr) => {\n        assert!($response.errors.is_empty(), \n            \"GraphQL errors: {:?}\", $response.errors);\n        assert_eq!($response.data, $expected, \n            \"Response data mismatch\");\n    };\n}\n\nmacro_rules! assert_review_valid {\n    ($review:expr) => {\n        assert!($review.id.is_some(), \"Review ID should be present\");\n        assert!(!$review.content.is_empty(), \"Review content should not be empty\");\n        assert!($review.rating >= 1 && $review.rating <= 5, \n            \"Rating should be between 1 and 5\");\n    };\n}\n\nmacro_rules! assert_database_state {\n    ($pool:expr, $table:expr, $count:expr) => {\n        let actual_count: i64 = sqlx::query_scalar(\n            &format!(\"SELECT COUNT(*) FROM {}\", $table)\n        ).fetch_one($pool).await.unwrap();\n        assert_eq!(actual_count, $count, \n            \"Expected {} records in {}, found {}\", $count, $table, actual_count);\n    };\n}")
        
        Component(test_utilities_impl, "TestUtilities", "Rust Helper Functions", "pub struct TestUtilities;\n\nimpl TestUtilities {\n    pub fn create_test_review() -> CreateReviewInput {\n        CreateReviewInput {\n            offer_id: Uuid::new_v4(),\n            author_id: Uuid::new_v4(),\n            content: \"Great car, highly recommended!\".to_string(),\n            rating: 5,\n        }\n    }\n    \n    pub async fn cleanup_database(pool: &PgPool) -> Result<(), sqlx::Error> {\n        sqlx::query(\"TRUNCATE TABLE reviews CASCADE\")\n            .execute(pool)\n            .await?;\n        Ok(())\n    }\n    \n    pub fn create_jwt_token(user_id: Uuid, role: UserRole) -> String {\n        let claims = Claims {\n            sub: user_id.to_string(),\n            role: role.to_string(),\n            exp: (Utc::now() + Duration::hours(1)).timestamp() as usize,\n        };\n        \n        encode(&Header::default(), &claims, &EncodingKey::from_secret(b\"test_secret\"))\n            .expect(\"Failed to create JWT token\")\n    }\n}")
    }
}

System_Boundary(integration_testing_impl, "Integration Testing Implementation") {
    
    System_Boundary(testcontainer_impl, "Testcontainer Implementation") {
        Component(database_container_impl, "DatabaseContainer", "Rust Testcontainers", "pub struct DatabaseContainer {\n    container: Container<'static, Postgres>,\n    connection_string: String,\n}\n\nimpl DatabaseContainer {\n    pub async fn new() -> Result<Self, TestError> {\n        let container = Postgres::default()\n            .with_db_name(\"test_db\")\n            .with_user(\"test_user\")\n            .with_password(\"test_password\")\n            .start()\n            .await?;\n        \n        let connection_string = format!(\n            \"postgresql://test_user:test_password@localhost:{}/test_db\",\n            container.get_host_port_ipv4(5432).await?\n        );\n        \n        Ok(Self {\n            container,\n            connection_string,\n        })\n    }\n    \n    pub fn connection_string(&self) -> &str {\n        &self.connection_string\n    }\n}")
        
        Component(redis_container_impl, "RedisContainer", "Rust Testcontainers", "pub struct RedisContainer {\n    container: Container<'static, Redis>,\n    connection_url: String,\n}\n\nimpl RedisContainer {\n    pub async fn new() -> Result<Self, TestError> {\n        let container = Redis::default().start().await?;\n        \n        let connection_url = format!(\n            \"redis://localhost:{}\",\n            container.get_host_port_ipv4(6379).await?\n        );\n        \n        Ok(Self {\n            container,\n            connection_url,\n        })\n    }\n}")
    }
    
    System_Boundary(graphql_testing_impl, "GraphQL Testing Implementation") {
        Component(graphql_test_client_impl, "GraphQLTestClient", "Rust Implementation", "pub struct GraphQLTestClient {\n    schema: Schema<Query, Mutation, EmptySubscription>,\n    context_data: HashMap<String, Box<dyn Any + Send + Sync>>,\n}\n\nimpl GraphQLTestClient {\n    pub fn new(schema: Schema<Query, Mutation, EmptySubscription>) -> Self {\n        Self {\n            schema,\n            context_data: HashMap::new(),\n        }\n    }\n    \n    pub fn with_context<T: Any + Send + Sync>(mut self, data: T) -> Self {\n        self.context_data.insert(\n            std::any::type_name::<T>().to_string(),\n            Box::new(data)\n        );\n        self\n    }\n    \n    pub async fn execute(&self, query: &str, variables: Variables) -> Response {\n        let mut request = Request::new(query).variables(variables);\n        \n        for (_, data) in &self.context_data {\n            // Add context data to request\n        }\n        \n        self.schema.execute(request).await\n    }\n}")
    }
}

System_Boundary(contract_testing_impl, "Contract Testing Implementation") {
    
    System_Boundary(pact_testing_impl, "Pact Testing Implementation") {
        Component(pact_consumer_impl, "PactConsumer", "Rust Pact Implementation", "use pact_consumer::prelude::*;\n\npub struct UserApiPactTest;\n\nimpl UserApiPactTest {\n    pub async fn test_get_user_by_id() -> Result<(), PactError> {\n        let pact = PactBuilder::new(\"UGC Service\", \"Users API\")\n            .interaction(\"get user by id\", |mut i| {\n                i.given(\"user exists with id 123\");\n                i.request.get().path(\"/users/123\");\n                i.response\n                    .status(200)\n                    .header(\"Content-Type\", \"application/json\")\n                    .json_body(json!({\n                        \"id\": \"123\",\n                        \"name\": \"John Doe\",\n                        \"email\": \"john@example.com\"\n                    }));\n            })\n            .build();\n        \n        let mock_server = pact.mock_server();\n        let client = UsersApiClient::new(&mock_server.url());\n        \n        let user = client.get_user(\"123\").await?;\n        assert_eq!(user.id, \"123\");\n        assert_eq!(user.name, \"John Doe\");\n        \n        Ok(())\n    }\n}")
        
        Component(schema_validator_impl, "SchemaValidator", "GraphQL Schema Validation", "pub struct SchemaValidator {\n    current_schema: String,\n    previous_schema: Option<String>,\n}\n\nimpl SchemaValidator {\n    pub fn new(schema: String) -> Self {\n        Self {\n            current_schema: schema,\n            previous_schema: None,\n        }\n    }\n    \n    pub fn with_previous_schema(mut self, schema: String) -> Self {\n        self.previous_schema = Some(schema);\n        self\n    }\n    \n    pub fn validate_compatibility(&self) -> Result<CompatibilityReport, ValidationError> {\n        if let Some(previous) = &self.previous_schema {\n            let changes = self.detect_changes(previous, &self.current_schema)?;\n            Ok(CompatibilityReport::new(changes))\n        } else {\n            Ok(CompatibilityReport::no_changes())\n        }\n    }\n    \n    fn detect_changes(&self, old: &str, new: &str) -> Result<Vec<SchemaChange>, ValidationError> {\n        // Schema diff implementation\n        todo!(\"Implement schema diff logic\")\n    }\n}")
    }
}

System_Boundary(e2e_testing_impl, "E2E Testing Implementation") {
    
    System_Boundary(scenario_runner_impl, "Scenario Runner Implementation") {
        Component(test_scenario_impl, "TestScenario", "Rust Test Framework", "pub struct TestScenario {\n    name: String,\n    steps: Vec<TestStep>,\n    setup: Option<Box<dyn Fn() -> BoxFuture<'static, Result<(), TestError>>>>,\n    teardown: Option<Box<dyn Fn() -> BoxFuture<'static, Result<(), TestError>>>>,\n}\n\nimpl TestScenario {\n    pub fn new(name: &str) -> Self {\n        Self {\n            name: name.to_string(),\n            steps: Vec::new(),\n            setup: None,\n            teardown: None,\n        }\n    }\n    \n    pub fn add_step(mut self, step: TestStep) -> Self {\n        self.steps.push(step);\n        self\n    }\n    \n    pub async fn execute(&self, context: &mut TestContext) -> Result<(), TestError> {\n        if let Some(setup) = &self.setup {\n            setup().await?;\n        }\n        \n        for step in &self.steps {\n            step.execute(context).await?;\n        }\n        \n        if let Some(teardown) = &self.teardown {\n            teardown().await?;\n        }\n        \n        Ok(())\n    }\n}")
        
        Component(performance_benchmark_impl, "PerformanceBenchmark", "Criterion Integration", "use criterion::{black_box, criterion_group, criterion_main, Criterion};\n\npub fn benchmark_graphql_queries(c: &mut Criterion) {\n    let rt = tokio::runtime::Runtime::new().unwrap();\n    let schema = create_test_schema();\n    \n    c.bench_function(\"simple_review_query\", |b| {\n        b.to_async(&rt).iter(|| async {\n            let query = r#\"\n                query GetReviews {\n                    reviews(first: 10) {\n                        edges {\n                            node {\n                                id\n                                content\n                                rating\n                            }\n                        }\n                    }\n                }\n            \"#;\n            \n            let response = schema.execute(query).await;\n            black_box(response)\n        })\n    });\n    \n    c.bench_function(\"complex_federation_query\", |b| {\n        b.to_async(&rt).iter(|| async {\n            let query = r#\"\n                query GetReviewsWithUserAndOffer {\n                    reviews(first: 5) {\n                        edges {\n                            node {\n                                id\n                                content\n                                rating\n                                author {\n                                    id\n                                    name\n                                }\n                                offer {\n                                    id\n                                    title\n                                    price\n                                }\n                            }\n                        }\n                    }\n                }\n            \"#;\n            \n            let response = schema.execute(query).await;\n            black_box(response)\n        })\n    });\n}\n\ncriterion_group!(benches, benchmark_graphql_queries);\ncriterion_main!(benches);")
    }
}

' Relationships between implementation components
Rel(test_config_impl, test_harness_impl, "configuration", "struct usage")
Rel(test_harness_impl, mock_factory_impl, "mock creation", "factory pattern")

Rel(custom_assertions_impl, test_utilities_impl, "assertion helpers", "utility functions")
Rel(test_utilities_impl, test_harness_impl, "test setup", "harness integration")

Rel(database_container_impl, redis_container_impl, "container management", "testcontainer coordination")
Rel(graphql_test_client_impl, test_harness_impl, "GraphQL testing", "test execution")

Rel(pact_consumer_impl, schema_validator_impl, "contract validation", "schema compatibility")

Rel(test_scenario_impl, performance_benchmark_impl, "performance testing", "benchmark execution")

SHOW_LEGEND()
@enduml