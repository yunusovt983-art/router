@startuml Task11_Code_Diagram
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml

title Auto.ru Federation - Code Diagram (Task 11: Subgraph Stubs Implementation)

System_Boundary(users_subgraph_implementation, "Users Subgraph Implementation") {
    
    System_Boundary(users_graphql_schema, "Users GraphQL Schema") {
        Component(users_entity_impl, "User Entity", "Rust Struct + GraphQL", "use async_graphql::{SimpleObject, ID};\n\n#[derive(SimpleObject, Clone)]\npub struct User {\n    pub id: ID,\n    pub name: String,\n    pub email: String,\n    pub phone: Option<String>,\n    pub created_at: String,\n    pub updated_at: String,\n}\n\n// Federation directive implementation\nimpl User {\n    // @key(fields: \"id\") implementation\n    pub fn reference_resolver(id: ID) -> Self {\n        // Entity resolution logic\n    }\n}")
        
        Component(users_query_impl, "Users Query", "GraphQL Query Root", "use async_graphql::{Context, Object, Result};\n\npub struct Query;\n\n#[Object]\nimpl Query {\n    #[graphql(desc = \"Get user by ID\")]\n    async fn user(\n        &self,\n        ctx: &Context<'_>,\n        id: ID\n    ) -> Result<Option<User>> {\n        let service = ctx.data::<Arc<UserService>>()?;\n        Ok(service.get_user_by_id(&id).await)\n    }\n    \n    #[graphql(desc = \"Get all users\")]\n    async fn users(\n        &self,\n        ctx: &Context<'_>\n    ) -> Result<Vec<User>> {\n        let service = ctx.data::<Arc<UserService>>()?;\n        Ok(service.get_users().await)\n    }\n    \n    // Federation entity resolver\n    async fn find_user_by_id(\n        &self,\n        ctx: &Context<'_>,\n        id: ID\n    ) -> Result<Option<User>> {\n        self.user(ctx, id).await\n    }\n}")
        
        Component(users_mutation_impl, "Users Mutation", "GraphQL Mutation Root", "pub struct Mutation;\n\n#[Object]\nimpl Mutation {\n    async fn create_user(\n        &self,\n        ctx: &Context<'_>,\n        input: CreateUserInput\n    ) -> Result<User> {\n        let service = ctx.data::<Arc<UserService>>()?;\n        service.create_user(input).await\n    }\n    \n    async fn update_user(\n        &self,\n        ctx: &Context<'_>,\n        id: ID,\n        input: UpdateUserInput\n    ) -> Result<Option<User>> {\n        let service = ctx.data::<Arc<UserService>>()?;\n        service.update_user(id, input).await\n    }\n    \n    async fn delete_user(\n        &self,\n        ctx: &Context<'_>,\n        id: ID\n    ) -> Result<bool> {\n        let service = ctx.data::<Arc<UserService>>()?;\n        service.delete_user(id).await\n    }\n}")
    }
    
    System_Boundary(users_service_impl, "Users Service Implementation") {
        Component(users_service_struct, "UserService", "Business Logic Service", "use std::sync::Arc;\nuse tokio::sync::RwLock;\n\npub struct UserService {\n    users: Arc<RwLock<Vec<User>>>,\n}\n\nimpl UserService {\n    pub fn new() -> Self {\n        let users = Self::generate_mock_users();\n        Self {\n            users: Arc::new(RwLock::new(users)),\n        }\n    }\n    \n    pub async fn get_user_by_id(&self, id: &str) -> Option<User> {\n        let users = self.users.read().await;\n        users.iter().find(|u| u.id == id).cloned()\n    }\n    \n    pub async fn get_users(&self) -> Vec<User> {\n        let users = self.users.read().await;\n        users.clone()\n    }\n    \n    pub async fn create_user(&self, input: CreateUserInput) -> Result<User, ServiceError> {\n        let mut users = self.users.write().await;\n        let user = User {\n            id: ID::from(uuid::Uuid::new_v4().to_string()),\n            name: input.name,\n            email: input.email,\n            phone: input.phone,\n            created_at: chrono::Utc::now().to_rfc3339(),\n            updated_at: chrono::Utc::now().to_rfc3339(),\n        };\n        users.push(user.clone());\n        Ok(user)\n    }\n}")
        
        Component(users_mock_data_impl, "Mock Data Generator", "Test Data Generation", "impl UserService {\n    fn generate_mock_users() -> Vec<User> {\n        let now = chrono::Utc::now().to_rfc3339();\n        \n        vec![\n            User {\n                id: ID::from(\"user-1\"),\n                name: \"Иван Иванов\".to_string(),\n                email: \"ivan@example.com\".to_string(),\n                phone: Some(\"+7-900-123-45-67\".to_string()),\n                created_at: now.clone(),\n                updated_at: now.clone(),\n            },\n            User {\n                id: ID::from(\"user-2\"),\n                name: \"Мария Петрова\".to_string(),\n                email: \"maria@example.com\".to_string(),\n                phone: Some(\"+7-900-765-43-21\".to_string()),\n                created_at: now.clone(),\n                updated_at: now.clone(),\n            },\n            User {\n                id: ID::from(\"user-3\"),\n                name: \"Алексей Сидоров\".to_string(),\n                email: \"alexey@example.com\".to_string(),\n                phone: None,\n                created_at: now.clone(),\n                updated_at: now,\n            },\n        ]\n    }\n}")
    }
}

System_Boundary(offers_subgraph_implementation, "Offers Subgraph Implementation") {
    
    System_Boundary(offers_graphql_schema, "Offers GraphQL Schema") {
        Component(offers_entity_impl, "Offer Entity", "Rust Struct + GraphQL", "#[derive(SimpleObject, Clone)]\npub struct Offer {\n    pub id: ID,\n    pub title: String,\n    pub description: String,\n    pub price: i32,\n    pub currency: String,\n    pub seller_id: ID, // Reference to User\n    pub car: Car,\n    pub location: String,\n    pub created_at: String,\n    pub updated_at: String,\n    pub status: OfferStatus,\n}\n\n#[derive(SimpleObject, Clone)]\npub struct Car {\n    pub make: String,\n    pub model: String,\n    pub year: i32,\n    pub mileage: Option<i32>,\n    pub fuel_type: FuelType,\n    pub transmission: TransmissionType,\n    pub color: String,\n    pub vin: Option<String>,\n}\n\n#[derive(Enum, Copy, Clone, Eq, PartialEq)]\npub enum OfferStatus {\n    Active,\n    Sold,\n    Inactive,\n}")
        
        Component(offers_query_impl, "Offers Query", "GraphQL Query Root", "#[Object]\nimpl Query {\n    async fn offer(\n        &self,\n        ctx: &Context<'_>,\n        id: ID\n    ) -> Result<Option<Offer>> {\n        let service = ctx.data::<Arc<OfferService>>()?;\n        Ok(service.get_offer_by_id(&id).await)\n    }\n    \n    async fn offers(\n        &self,\n        ctx: &Context<'_>,\n        filter: Option<OfferFilter>,\n        first: Option<i32>,\n        after: Option<String>\n    ) -> Result<OfferConnection> {\n        let service = ctx.data::<Arc<OfferService>>()?;\n        service.get_offers(filter, first, after).await\n    }\n    \n    async fn cars(\n        &self,\n        ctx: &Context<'_>,\n        make: Option<String>\n    ) -> Result<Vec<Car>> {\n        let service = ctx.data::<Arc<OfferService>>()?;\n        Ok(service.get_cars(make).await)\n    }\n    \n    // Federation entity resolver\n    async fn find_offer_by_id(\n        &self,\n        ctx: &Context<'_>,\n        id: ID\n    ) -> Result<Option<Offer>> {\n        self.offer(ctx, id).await\n    }\n}")
        
        Component(offers_mutation_impl, "Offers Mutation", "GraphQL Mutation Root", "#[Object]\nimpl Mutation {\n    async fn create_offer(\n        &self,\n        ctx: &Context<'_>,\n        input: CreateOfferInput\n    ) -> Result<Offer> {\n        let service = ctx.data::<Arc<OfferService>>()?;\n        service.create_offer(input).await\n    }\n    \n    async fn update_offer(\n        &self,\n        ctx: &Context<'_>,\n        id: ID,\n        input: UpdateOfferInput\n    ) -> Result<Option<Offer>> {\n        let service = ctx.data::<Arc<OfferService>>()?;\n        service.update_offer(id, input).await\n    }\n    \n    async fn delete_offer(\n        &self,\n        ctx: &Context<'_>,\n        id: ID\n    ) -> Result<bool> {\n        let service = ctx.data::<Arc<OfferService>>()?;\n        service.delete_offer(id).await\n    }\n}")
    }
    
    System_Boundary(offers_service_impl, "Offers Service Implementation") {
        Component(offers_service_struct, "OfferService", "Business Logic Service", "pub struct OfferService {\n    offers: Arc<RwLock<Vec<Offer>>>,\n}\n\nimpl OfferService {\n    pub fn new() -> Self {\n        let offers = Self::generate_mock_offers();\n        Self {\n            offers: Arc::new(RwLock::new(offers)),\n        }\n    }\n    \n    pub async fn get_offer_by_id(&self, id: &str) -> Option<Offer> {\n        let offers = self.offers.read().await;\n        offers.iter().find(|o| o.id == id).cloned()\n    }\n    \n    pub async fn get_offers(\n        &self,\n        filter: Option<OfferFilter>,\n        first: Option<i32>,\n        after: Option<String>\n    ) -> Result<OfferConnection, ServiceError> {\n        let offers = self.offers.read().await;\n        let filtered = self.apply_filter(&offers, filter);\n        let paginated = self.apply_pagination(filtered, first, after);\n        Ok(OfferConnection::from_offers(paginated))\n    }\n    \n    fn apply_filter(&self, offers: &[Offer], filter: Option<OfferFilter>) -> Vec<Offer> {\n        match filter {\n            Some(f) => offers.iter()\n                .filter(|o| self.matches_filter(o, &f))\n                .cloned()\n                .collect(),\n            None => offers.to_vec(),\n        }\n    }\n}")
        
        Component(offers_mock_data_impl, "Mock Offers Generator", "Automotive Test Data", "impl OfferService {\n    fn generate_mock_offers() -> Vec<Offer> {\n        let now = chrono::Utc::now().to_rfc3339();\n        \n        vec![\n            Offer {\n                id: ID::from(\"offer-1\"),\n                title: \"Toyota Camry 2020 в отличном состоянии\".to_string(),\n                description: \"Продаю Toyota Camry 2020 года...\".to_string(),\n                price: 2500000,\n                currency: \"RUB\".to_string(),\n                seller_id: ID::from(\"user-1\"),\n                car: Car {\n                    make: \"Toyota\".to_string(),\n                    model: \"Camry\".to_string(),\n                    year: 2020,\n                    mileage: Some(45000),\n                    fuel_type: FuelType::Gasoline,\n                    transmission: TransmissionType::Automatic,\n                    color: \"Белый\".to_string(),\n                    vin: Some(\"JT2BF28K123456789\".to_string()),\n                },\n                location: \"Москва\".to_string(),\n                created_at: now.clone(),\n                updated_at: now.clone(),\n                status: OfferStatus::Active,\n            },\n            // More mock offers...\n        ]\n    }\n}")
    }
}

System_Boundary(federation_integration_impl, "Federation Integration Implementation") {
    
    System_Boundary(schema_composition, "Schema Composition") {
        Component(federation_schema_impl, "Federation Schema", "GraphQL Federation Setup", "use async_graphql::{Schema, EmptySubscription};\n\n// Users subgraph schema\npub fn create_users_schema() -> Schema<Query, Mutation, EmptySubscription> {\n    Schema::build(Query, Mutation, EmptySubscription)\n        .data(Arc::new(UserService::new()))\n        .enable_federation()\n        .finish()\n}\n\n// Offers subgraph schema\npub fn create_offers_schema() -> Schema<Query, Mutation, EmptySubscription> {\n    Schema::build(Query, Mutation, EmptySubscription)\n        .data(Arc::new(OfferService::new()))\n        .enable_federation()\n        .finish()\n}\n\n// Federation directives\n// @key(fields: \"id\") on User and Offer types\n// @extends on types that extend entities from other subgraphs")
        
        Component(entity_resolver_impl, "Entity Resolver", "Federation Entity Resolution", "use async_graphql::{Context, Result};\n\n// User entity resolver\npub async fn resolve_user_entity(\n    ctx: &Context<'_>,\n    id: ID\n) -> Result<Option<User>> {\n    let service = ctx.data::<Arc<UserService>>()?;\n    Ok(service.get_user_by_id(&id).await)\n}\n\n// Offer entity resolver\npub async fn resolve_offer_entity(\n    ctx: &Context<'_>,\n    id: ID\n) -> Result<Option<Offer>> {\n    let service = ctx.data::<Arc<OfferService>>()?;\n    Ok(service.get_offer_by_id(&id).await)\n}\n\n// Cross-subgraph reference resolution\nimpl Offer {\n    async fn seller(&self, ctx: &Context<'_>) -> Result<Option<User>> {\n        // This would be resolved by Apollo Router\n        // through federation to Users subgraph\n        Ok(None) // Placeholder in stub\n    }\n}")
    }
    
    System_Boundary(server_setup, "Server Setup Implementation") {
        Component(users_server_impl, "Users Server", "Axum HTTP Server", "use axum::{Router, routing::{get, post}};\nuse tower_http::cors::CorsLayer;\n\npub async fn run_users_server() -> Result<(), Box<dyn std::error::Error>> {\n    let schema = create_users_schema();\n    let state = AppState { schema };\n    \n    let app = Router::new()\n        .route(\"/graphql\", post(graphql_handler))\n        .route(\"/health\", get(health_check))\n        .route(\"/.well-known/jwks.json\", get(jwks))\n        .layer(CorsLayer::permissive())\n        .with_state(state);\n    \n    let listener = TcpListener::bind(\"0.0.0.0:4002\").await?;\n    info!(\"Users Subgraph listening on http://0.0.0.0:4002\");\n    \n    axum::serve(listener, app).await?;\n    Ok(())\n}\n\npub async fn graphql_handler(\n    State(state): State<AppState>,\n    req: GraphQLRequest,\n) -> GraphQLResponse {\n    state.schema.execute(req.into_inner()).await.into()\n}")
        
        Component(offers_server_impl, "Offers Server", "Axum HTTP Server", "pub async fn run_offers_server() -> Result<(), Box<dyn std::error::Error>> {\n    let schema = create_offers_schema();\n    let state = AppState { schema };\n    \n    let app = Router::new()\n        .route(\"/graphql\", post(graphql_handler))\n        .route(\"/health\", get(health_check))\n        .route(\"/metrics\", get(metrics_handler))\n        .layer(CorsLayer::permissive())\n        .with_state(state);\n    \n    let listener = TcpListener::bind(\"0.0.0.0:4004\").await?;\n    info!(\"Offers Subgraph listening on http://0.0.0.0:4004\");\n    \n    axum::serve(listener, app).await?;\n    Ok(())\n}\n\npub async fn health_check() -> Json<Value> {\n    Json(json!({\n        \"status\": \"healthy\",\n        \"service\": \"offers-subgraph\",\n        \"timestamp\": chrono::Utc::now().to_rfc3339(),\n        \"version\": env!(\"CARGO_PKG_VERSION\")\n    }))\n}")
    }
}

System_Boundary(testing_implementation, "Testing Implementation") {
    
    System_Boundary(unit_tests_impl, "Unit Tests Implementation") {
        Component(users_unit_tests, "Users Unit Tests", "Rust Test Framework", "#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[tokio::test]\n    async fn test_get_user_by_id() {\n        let service = UserService::new();\n        let user = service.get_user_by_id(\"user-1\").await;\n        \n        assert!(user.is_some());\n        let user = user.unwrap();\n        assert_eq!(user.id, \"user-1\");\n        assert_eq!(user.name, \"Иван Иванов\");\n    }\n    \n    #[tokio::test]\n    async fn test_create_user() {\n        let service = UserService::new();\n        let input = CreateUserInput {\n            name: \"Test User\".to_string(),\n            email: \"test@example.com\".to_string(),\n            phone: None,\n        };\n        \n        let result = service.create_user(input).await;\n        assert!(result.is_ok());\n        \n        let user = result.unwrap();\n        assert_eq!(user.name, \"Test User\");\n        assert_eq!(user.email, \"test@example.com\");\n    }\n}")
        
        Component(offers_unit_tests, "Offers Unit Tests", "Rust Test Framework", "#[tokio::test]\nasync fn test_get_offers_with_filter() {\n    let service = OfferService::new();\n    let filter = OfferFilter {\n        make: Some(\"Toyota\".to_string()),\n        price_min: Some(2000000),\n        price_max: Some(3000000),\n        status: Some(OfferStatus::Active),\n    };\n    \n    let result = service.get_offers(Some(filter), None, None).await;\n    assert!(result.is_ok());\n    \n    let connection = result.unwrap();\n    assert!(!connection.edges.is_empty());\n    \n    for edge in connection.edges {\n        let offer = edge.node;\n        assert_eq!(offer.car.make, \"Toyota\");\n        assert!(offer.price >= 2000000 && offer.price <= 3000000);\n        assert_eq!(offer.status, OfferStatus::Active);\n    }\n}")
    }
    
    System_Boundary(integration_tests_impl, "Integration Tests Implementation") {
        Component(federation_integration_tests, "Federation Integration Tests", "GraphQL Test Client", "#[tokio::test]\nasync fn test_cross_subgraph_query() {\n    let users_schema = create_users_schema();\n    let offers_schema = create_offers_schema();\n    \n    // Test federation query that spans both subgraphs\n    let query = r#\"\n        query GetOfferWithSeller($offerId: ID!) {\n            offer(id: $offerId) {\n                id\n                title\n                price\n                seller {\n                    id\n                    name\n                    email\n                }\n            }\n        }\n    \"#;\n    \n    // This would be tested through Apollo Router in real scenario\n    // Here we test individual subgraph responses\n    let offer_response = offers_schema.execute(Request::new(query)\n        .variables(Variables::from_json(json!({\n            \"offerId\": \"offer-1\"\n        })))).await;\n    \n    assert!(offer_response.errors.is_empty());\n    // Additional assertions...\n}")
    }
}

' Relationships between implementation components
Rel(users_entity_impl, users_query_impl, "entity usage", "GraphQL type")
Rel(users_query_impl, users_service_struct, "service calls", "business logic")
Rel(users_service_struct, users_mock_data_impl, "data access", "mock data")

Rel(offers_entity_impl, offers_query_impl, "entity usage", "GraphQL type")
Rel(offers_query_impl, offers_service_struct, "service calls", "business logic")
Rel(offers_service_struct, offers_mock_data_impl, "data access", "mock data")

Rel(federation_schema_impl, entity_resolver_impl, "entity resolution", "federation")
Rel(users_server_impl, federation_schema_impl, "schema usage", "GraphQL server")
Rel(offers_server_impl, federation_schema_impl, "schema usage", "GraphQL server")

Rel(users_unit_tests, users_service_struct, "testing", "unit tests")
Rel(offers_unit_tests, offers_service_struct, "testing", "unit tests")
Rel(federation_integration_tests, federation_schema_impl, "testing", "integration tests")

SHOW_LEGEND()
@enduml